// examples/ml_residual_example.cpp
// Example showing how to integrate ml_addon into an existing control loop (e.g., LemLib)
#include "pros/apix.h"
#include "ml_addon/ml_addon.hpp"
#include "ml_addon/nn_weights.h" // generated by train_export.py

using namespace ml_addon;

int main() {
    pros::lcd::initialize();
    // Prepare MLP and scaler (scaler params should be exported by scale_stats.py)
    MLP net;
    net.load_from_arrays(ML_ADDON_W, ML_ADDON_B, ML_ADDON_SIZES, ML_ADDON_ACTS);

    // Example: suppose your controller wants to add a residual velocity correction
    // Input features example: [target_rpm, battery_volts, current_rpm, x, y]
    // For demo we'll use zeros
    std::vector<float> features(net.input_size(), 0.0f);

    // Example loop
    while (true) {
        pros::delay(10); // 100Hz
        // update features from sensors here...
        std::vector<float> out = net.infer(features);
        // out contains residuals (e.g., in same units as velocity)
        float residual_left = out.size() > 0 ? out[0] : 0.0f;
        float residual_right = out.size() > 1 ? out[1] : residual_left;
        // apply residual scaled small as safety
        // e.g., set motor targets = base_target + 0.05 * residual
        // your integration with LemLib: pass residual to feedforward or to a wrapper
        pros::lcd::set_text(2, ("resL: " + std::to_string(residual_left)).c_str());
    }
    return 0;
}
